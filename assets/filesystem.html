<!DOCTYPE html>
<html lang="zh">

<head>
	<meta charset="UTF-8">
	<title>æ–‡ä»¶å¤åˆ¶å·¥å…·</title>
	<style>
		body {
			font-family: Arial;
			padding: 20px;
		}

		.container {
			display: flex;
			gap: 40px;
		}

		.panel {
			flex: 1;
		}

		ul {
			list-style: none;
			padding: 0;
			border: 1px solid #ccc;
			height: 300px;
			overflow-y: auto;
		}

		li {
			padding: 5px;
			cursor: pointer;
		}

		li.selected {
			background-color: #b3d4fc;
		}

		.dir::before {
			content: "ğŸ“ ";
		}

		.file::before {
			content: "ğŸ“„ ";
		}

		.pathinput_container {
			display: flex;
			gap: 20px;
		}

		.pathinput {
			flex-grow: 1;
		}

		.control_container {
			display: flex;
			flex-direction: column;
			justify-content: center;
			gap: 30px;
		}
	</style>
</head>

<body>

	<h1>æ–‡ä»¶å¤åˆ¶å·¥å…·</h1>

	<div class="container">
		<div class="panel">
			<div class="pathinput_container">
				<input type="text" id="path1" class="pathinput">
				<button onclick="loadList('path1', 'list1')" value="D:\">åŠ è½½</button>
			</div>
			<h3>æ–‡ä»¶åˆ—è¡¨</h3>
			<ul id="list1" onclick="selectItem(event, 'list1')" ondblclick="enterFolder(event, 'path1', 'list1')"></ul>
			<button onclick="deleteFile('path1', 'list1')">åˆ é™¤é€‰ä¸­é¡¹</button>
		</div>
		<div class="control_container">
			<button onclick="copyFile()">å¤åˆ¶ &gt;&gt;</button>
		</div>
		<div class="panel">
			<div class="pathinput_container">
				<input type="text" id="path2" class="pathinput">
				<button onclick="loadList('path2', 'list2')" value="D:\">åŠ è½½</button>
			</div>
			<h3>æ–‡ä»¶åˆ—è¡¨</h3>
			<ul id="list2" onclick="selectItem(event, 'list2')" ondblclick="enterFolder(event, 'path2', 'list2')"></ul>
			<button onclick="deleteFile('path2', 'list2')">åˆ é™¤é€‰ä¸­é¡¹</button>
		</div>
	</div>

	<script>
		const selected = { list1: null, list2: null };
		const pathState = {
			list1: [],
			list2: []
		};

		async function fetchFiles(fullPath) {
			try {
				const response = await fetch('/wsf-rpc/call', {
					method: 'POST',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({
						name: "ListFile", params: {
							path: fullPath
						}
					})
				});

				const data = await response.json();
				return data["params"]["result"];
			} catch (err) {
				alert('åŠ è½½å¤±è´¥: ' + err.message);
			}
		}

		async function applyToList(filelist, listId) {
			const listEl = document.getElementById(listId);
			listEl.innerHTML = '';
			selected[listId] = null;

			// æ·»åŠ â€œè¿”å›ä¸Šä¸€çº§â€æŒ‰é’®ï¼ˆå¦‚æœå½“å‰è·¯å¾„ä¸æ˜¯æ ¹è·¯å¾„ï¼‰
			const li = document.createElement('li');
			li.textContent = '..';
			li.dataset.type = 'up';
			listEl.appendChild(li);

			filelist.forEach(file => {
				const li = document.createElement('li');
				li.textContent = file.name;
				li.dataset.name = file.name;
				li.dataset.type = file.type;
				li.classList.add(file.type);
				listEl.appendChild(li);
			});
		}

		async function loadList(pathId, listId) {
			const path = document.getElementById(pathId).value;
			if (!path || path === '') {
				alert('è¯·è¾“å…¥è·¯å¾„');
				return;
			}

			const filelist = await fetchFiles(path);
			await applyToList(filelist, listId);
		}

		function selectItem(event, listId) {
			if (event.target.tagName !== 'LI') return;

			const items = document.getElementById(listId).children;
			for (let item of items) {
				item.classList.remove('selected');
			}
			event.target.classList.add('selected');
			selected[listId] = event.target.dataset.name;
		}

		function enterFolder(event, pathId, listId) {
			const li = event.target;
			const basePath = document.getElementById(pathId).value;
			if (li.dataset.type === 'dir') {
				const newFullPath = [basePath, li.dataset.name].join('/');
				document.getElementById(pathId).value = newFullPath;
				loadList(pathId, listId);
			} else if (li.dataset.type === 'up') {
				// è¿”å›ä¸Šä¸€çº§
				const newFullPath = basePath.replace(/\/[^/]*$/, '');
				document.getElementById(pathId).value = newFullPath;
				loadList(pathId, listId);
			}
		}

		async function copyFile() {
			const sourceBase = document.getElementById('path1').value;
			const targetBase = document.getElementById('path2').value;
			const fileName = selected['list1'];

			if (!fileName) {
				alert('è¯·ä»è·¯å¾„1ä¸­é€‰æ‹©è¦å¤åˆ¶çš„æ–‡ä»¶');
				return;
			}

			const sourcePath = [sourceBase, fileName].join('/').replace(/\/+/g, '/');
			const targetPath = targetBase;

			try {
				const res = await fetch('/wsf-rpc/call', {
					method: 'POST',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({
						name: "CopyFile",
						params: {
							srcFilename: sourcePath,
							dstDir: targetPath
						}
					})
				});

				const result = await res.json();
				if (result.params.error) {
					alert('å¤åˆ¶å¤±è´¥ï¼š' + result.params.error);
				} else {
					alert('å¤åˆ¶æˆåŠŸ');
					await applyToList(result["params"]["result"], "list2");
				}
			} catch (err) {
				alert('å¤åˆ¶å‡ºé”™: ' + err.message);
			}
		}

		async function deleteFile(pathId, listId) {
			// åˆ¤æ–­å“ªä¸ªåˆ—è¡¨è¢«é€‰ä¸­äº†ï¼ˆè¿™é‡Œåªæ”¯æŒä» list1 åˆ é™¤ï¼‰
			const fileName = selected[listId];
			if (!fileName) {
				alert('è¯·é€‰æ‹©è¦åˆ é™¤çš„æ–‡ä»¶');
				return;
			}

			const basePath = document.getElementById(pathId).value;
			const fullPath = [basePath, selected[listId]].join('/');

			// æŸ¥æ‰¾æ‰€é€‰é¡¹çš„ç±»å‹ï¼Œç¡®è®¤æ˜¯å¦æ˜¯æ–‡ä»¶ï¼ˆä¸å…è®¸åˆ é™¤ç›®å½•ï¼‰
			const listItems = document.getElementById(listId).children;
			let fileType = null;
			for (let item of listItems) {
				if (item.classList.contains('selected')) {
					fileType = item.dataset.type;
					break;
				}
			}

			if (fileType !== 'file') {
				alert('åªèƒ½åˆ é™¤æ–‡ä»¶ï¼Œä¸èƒ½åˆ é™¤ç›®å½•');
				return;
			}

			const confirmDelete = confirm(`ç¡®å®šè¦åˆ é™¤æ–‡ä»¶ "${fullPath}" å—ï¼Ÿ`);
			if (!confirmDelete) return;

			try {
				const res = await fetch('/wsf-rpc/call', {
					method: 'POST',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({
						name: "DeleteFile",
						params: {
							filename: fullPath,
						}
					})
				});

				const result = await res.json();
				if (result.params.error) {
					alert('åˆ é™¤å¤±è´¥ï¼š' + result.params.error);
				} else {
					alert('åˆ é™¤æˆåŠŸ');
					await applyToList(result["params"]["result"], listId);
				}
			} catch (err) {
				alert('åˆ é™¤æ—¶å‡ºé”™ï¼š' + err.message);
			}
		}
	</script>

</body>

</html>